<section class="w-full h-screen">
  <div
    id="image-track"
    class="grid lg:grid-cols-3 gap-6"
    data-mouse-down-at="0"
    data-prev-percentage="0"
  >
    {% for item in site.data.information.work.gallery %}
    <div class="image-card">
      <div
        class="bg-image-style aspect-portrait border-[16px] {% cycle 'border-accent', 'border-main' %}"
        style="background-image: url('{{ item.image_path }}');"
        draggable="false"
      ></div>
      <div
        class="{% cycle 'bg-accent', 'bg-main' %} pt-8 pb-8 px-4 lg:flex justify-between"
      >
        <h3 class="subtitle text-light mb-2 uppercase" data-aos="fade-in">
          {{ item.name }}
        </h3>
        <span class="subtitle text-light" data-aos="fade-in">
          {{ item.location }}
        </span>
      </div>
    </div>
    <!-- Delete the image-card below as its only for testing  -->
    <div class="image-card">
      <div
        class="bg-image-style aspect-portrait border-[16px] {% cycle 'border-accent', 'border-main' %}"
        style="background-image: url('{{ item.image_path }}');"
        draggable="false"
      ></div>
      <div
        class="{% cycle 'bg-accent', 'bg-main' %} pt-8 pb-8 px-4 lg:flex justify-between"
      >
        <h3 class="subtitle text-light mb-2 uppercase" data-aos="fade-in">
          {{ item.name }}
        </h3>
        <span class="subtitle text-light" data-aos="fade-in">
          {{ item.location }}
        </span>
      </div>
    </div>
    {% endfor %}
  </div>
</section>
<style>
  #image-track {
    display: flex;
    gap: 2vmin;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  #image-track::-webkit-scrollbar {
    display: none; /* For Chrome, Safari, and Opera */
  }

  .image-card {
    flex: 0 0 33.333%; /* Adjust based on your design */ /* Ensure each card takes up one-third of the track width */
    scroll-snap-align: center;
    transition: transform 0.3s ease-in-out;
    transform: scale(0.8); /* Default smaller scale for non-centered cards */
  }

  .image-card.center {
    transform: scale(0.9);
  }

  /* Mobile-specific styles */
  @media (max-width: 767px) {
    .image-card {
      flex: 0 0 80%; /* Adjust this value to show one full and part of the next image */
      width: 80%; /* This width allows one card to be fully visible and the next card to peek */
    }
  }
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenMax.min.js"></script>

<script>
  // Get the track element and all card elements within it
  const track = document.getElementById("image-track");
  const cards = document.querySelectorAll(".image-card");
  const cursor = document.querySelector(".cursor"); // Get the custom cursor element

  // Variables to track the state of dragging
  let isDragging = false;
  let startPos = 0;
  let startScrollLeft = 0;
  let velocity = 0;
  let lastTime = 0;

  // Function to handle the mouse down or touch start event
  const handleOnDown = (e) => {
    isDragging = true; // Set dragging to true
    startPos = e.clientX; // Record the initial mouse position
    startScrollLeft = track.scrollLeft; // Record the initial scroll position
    track.style.scrollBehavior = "auto"; // Disable smooth scrolling for direct control
    velocity = 0; // Reset velocity
    lastTime = performance.now(); // Record the current time
    // Add event listeners for mouse move and mouse up
    document.addEventListener("mousemove", handleOnMove);
    document.addEventListener("mouseup", handleOnUp);
    document.addEventListener("mouseleave", handleOnUp); // Stop dragging if the mouse leaves the window
  };

  // Function to handle the mouse move or touch move event
  const handleOnMove = (e) => {
    if (!isDragging) return; // If not dragging, do nothing
    const currentTime = performance.now();
    const timeDelta = currentTime - lastTime; // Calculate time difference

    const mouseDelta = startPos - e.clientX; // Calculate mouse movement
    velocity = (mouseDelta / timeDelta) * 1000; // Calculate velocity in pixels per second

    track.scrollLeft = startScrollLeft + mouseDelta; // Update scroll position

    startPos = e.clientX; // Update the current mouse position
    startScrollLeft = track.scrollLeft; // Update the current scroll position
    lastTime = currentTime; // Update the last recorded time

    updateScale(); // Update scaling of cards based on their position
  };

  // Function to handle the mouse up or touch end event
  const handleOnUp = () => {
    isDragging = false; // Set dragging to false
    track.style.scrollBehavior = "smooth"; // Re-enable smooth scrolling
    // Remove event listeners
    document.removeEventListener("mousemove", handleOnMove);
    document.removeEventListener("mouseup", handleOnUp);
    document.removeEventListener("mouseleave", handleOnUp);

    animateDeceleration(); // Start the deceleration effect
  };

  // Function to animate the deceleration of the scroll
  const animateDeceleration = () => {
    if (Math.abs(velocity) > 10) {
      track.scrollLeft += velocity * 0.9; // Apply velocity to scroll position
      velocity *= 0.98; // Apply damping to reduce velocity
      requestAnimationFrame(animateDeceleration); // Continue animation
    } else {
      updateScale(); // Final update to scale when stopping
    }
  };

  // Function to update the scale of cards based on their center alignment
  const updateScale = () => {
    const trackRect = track.getBoundingClientRect();
    const centerPosition = trackRect.left + trackRect.width / 2;

    cards.forEach((card) => {
      const cardRect = card.getBoundingClientRect();
      const cardCenter = cardRect.left + cardRect.width / 2;
      const dist = Math.abs(centerPosition - cardCenter); // Calculate distance from center

      if (dist < cardRect.width / 2) {
        card.classList.add("center"); // Add 'center' class if close to center
      } else {
        card.classList.remove("center"); // Remove 'center' class if not
      }
    });
  };

  // Initialize the scale for the center card on page load
  document.addEventListener("DOMContentLoaded", () => {
    updateScale();
  });

  // Attach event handlers for dragging
  track.onmousedown = handleOnDown;
  track.ontouchstart = (e) => handleOnDown(e.touches[0]);

  TweenMax.to({}, 0.016, {
    repeat: -1,
    onRepeat: function () {
      posX += (mouseX - posX) / 9;
      posY += (mouseY - posY) / 9;
      TweenMax.set(cursor, {
        css: {
          left: posX - 20,
          top: posY - 20,
        },
      });
    },
  });

  // Update mouse position on mousemove
  document.addEventListener("mousemove", function (e) {
    mouseX = e.pageX;
    mouseY = e.pageY;
  });

  // Add and remove active class to cursor based on hover over the track
  track.addEventListener("mouseenter", () => {
    cursor.classList.add("active");
  });
  track.addEventListener("mouseleave", () => {
    cursor.classList.remove("active");
  });
</script>
